#include "Header.h"               //подключение библиотеки

void symmetric_show(tree* node);  //функция обхода дерева симметричным способом, или симметричный обход(inorder)
void width_show(tree* node);      //функция обхода дерева в прямом порядке, прямой обход, упорядоченный обход, обход сверху, или обход в ширину(preorder)
void deep_show(tree* node);       //функция обхода дерева в обратном порядке, обход в глубину, обратный обход, обход снизу(postorder)

void show_menu(tree* root)        //функция меню нерекурсивного вывода содержимого бинарного дерева
{
	while (1)
	{
		printf("%c[%d;%dm\nВыберите вариант обхода дерева:%c[%dm", 27, 1, 34, 27, 0);
		puts("\n1 - симметричный"
			"\n2 - прямой(в ширину)"
			"\n3 - обратный(в глубину)\n");
		switch (char c = _getch())
		{
		case '1': symmetric_show(root); break;  //вызов функции обхода дерева симметричным способом
		case '2': width_show(root); break;      //вызов функции обхода дерева в прямом порядке
		case '3': deep_show(root); break;       //вызов функции обхода в обратном порядке
		default: printf("%c[%d;%dm\nОшибка выбора обхода!%c[%dm\n", 27, 1, 31, 27, 0); 
			continue;
		} break;
	}
	printf("\n\n");               //переход на новую строку
}

void symmetric_show(tree* node)   //функция обхода симметричным способом, или симметричный обход(inorder).
//При симметричном обходе обрабатывается сначала левое поддерево, затем корень, а затем правое поддерево.
{
	stack* head = NULL, *newHead = NULL; //указатели на вершину стека и на новый элемент, добавляемый в стек, соответственно
	if (!node)                           //если дерево не создано
	{ 
		printf("%c[%d;%dm\nДерево пустое!%c[%dm\n", 27, 1, 31, 27, 0);
		return; 
	}
	int flag = 1;                        //flag = 1 - признак движения влево по ветви дерева
	if(!(head = (stack *)calloc(1, sizeof(stack)))) //выделение памяти под вершину стека
	{
		printf("%c[%d;%dm\nПамять не выделена!%c[%dm\n", 27, 1, 31, 27, 0);
		return;
    }
	head->node = node;                   //вершина стека - это корень дерева
	head->next = NULL;                   //указатель на следующий элемент стека
	while (head || node->right)          //цикл пока стек не пустой и есть движение вправо по дереву
	{
		do                               //цикл пока не лист дерева
		{
			if (flag && node->left) node = node->left;  // переход на узел слева
			else if (node->right) node = node->right;   // переход на узел cправа
			flag = 1;                    //сброс принудительного движения вправо
			if (!(newHead = (stack *)calloc(1, sizeof(stack)))) //выделение памяти под новый элемент стека
			{
				printf("%c[%d;%dm\nПамять не выделена!%c[%dm\n", 27, 1, 31, 27, 0);
				return;
			}
			newHead->node = node;        //указатель на найденый узел дерева
			newHead->next = head;        //указатель из вершины стека на предыдущий 
			head = newHead;              //новая вершина стека
		} while (node && node->left);
		while (head && (!node->right || !node->left)) //цикл по выводу содержимого стека, пока стек не пуст и не узел с двумя ветвями
		{
			newHead = head;              //указатель на вершину стека
			node = head->node;           //возвращаемя на этот узел ветвления в дереве	
			head = head->next;           //указатель вниз на следующий элемент стека
			free(newHead);               //удаление из стека вершины
			printf("%d ", node->info);   //вывод удаленной вершины стека
		}
		if (node->right) flag = 0;       //устанавливаем признак принудительного перехода направо
		else break;
	}
}

void width_show(tree* node) //функция обхода в прямом порядке, прямой обход, упорядоченный обход, обход сверху, или обход в ширину(preorder).
//При прямом обходе обрабатывается сначала корень, затем левое поддерево, а потом правое.
{
	stack* head = NULL, *newHead = NULL; //указатели на вершину стека и на новый элемент, добавляемый в стек, соответственно
	if (!node)                           //если дерево не создано
	{ 
		printf("%c[%d;%dm\nДерево пустое!%c[%dm\n", 27, 1, 31, 27, 0);
		return; 
	}
	int flag = 1;                        //flag = 1 - признак движения влево по ветви дерева
	if (!(head = (stack *)calloc(1, sizeof(stack)))) //выделение памяти под вершину стека
	{
		printf("%c[%d;%dm\nПамять не выделена!%c[%dm\n", 27, 1, 31, 27, 0);
		return;
	}
	head->node = node;                   //вершина стека - это корень дерева
	head->next = NULL;                   //указатель на следующий элемент стека
	printf("%d ", node->info);           //вывод корня дерева
	while (head || node->right)          //цикл пока стек не пустой и есть движение вправо по дереву
	{
		do                               //цикл пока не лист дерева
		{
			if (flag && node->left) node = node->left;  // переход на узел слева
			else if (node->right) node = node->right;   // переход на узел cправа
			printf("%d ", node->info);
			flag = 1;                                   //сброс принудительного движения вправо
			if (node->left && node->right)              //узел имеет две ветки
			{
				if (!(newHead = (stack *)calloc(1, sizeof(stack)))) //выделение памяти под новый элемент стека
				{
					printf("%c[%d;%dm\nПамять не выделена!%c[%dm\n", 27, 1, 31, 27, 0);
					return;
				}
				newHead->node = node;    //указатель на найденый узел дерева
				newHead->next = head;    //указатель из вершины стека на предыдущий 
				head = newHead;          //новая вершина стека
			}
		} while (node->left || node->right);
		if(head)                         //если стек не пуст
		{
			newHead = head;              //указатель на вершину стека
			node = head->node;           //возврат на этот узел ветвления в дереве	
			head = head->next;           //указатель вниз на следующий элемент стека
			free(newHead);               //удаление из стека указателя на выбранный узел
		}
		if (node->right || node->left) flag = 0;   //устанавливаем признак принудительного перехода направо 
		else break;
	}
}

void deep_show(tree* node) //функция обхода в обратном порядке, обход в глубину, обратный обход, обход снизу(postorder).
//При обходе снизу сначала обрабатывается левое поддерево, затем правое и, наконец корень.
{
	stack* head = NULL, *newHead = NULL; //указатели на вершину стека и на новый элемент, добавляемый в стек, соответственно
	tree* root = node;                   //запомнили корень дерева для будущего сравнения
	if (!node)                           //дерево не создано
	{
		printf("%c[%d;%dm\nДерево пустое!%c[%dm\n", 27, 1, 31, 27, 0);
		return; 
	}
	int flag = 1, flag1 = 0;             //flag = 1 - признак движения влево по ветви дерева
	if (!(head = (stack *)calloc(1, sizeof(stack)))) //выделение памяти под вершину стека
	{
		printf("%c[%d;%dm\nПамять не выделена!%c[%dm\n", 27, 1, 31, 27, 0);
		return;
	}
	head->node = node;                   //вершина стека - это корень дерева
	head->next = NULL;                   //указатель на следующий элемент стека
	while (head || node->right)          //цикл пока стек не пустой и есть движение вправо по дереву
	{
		do                               //цикл пока не лист дерева
		{
			if (flag && node->left) node = node->left;  // переход на узел слева
			else if (node->right) node = node->right;   // переход на узел cправа
			flag = 1;                    //сброс принудительного движения вправо
			if (!(newHead = (stack *)calloc(1, sizeof(stack)))) //выделение памяти под новый элемент стека
			{
				printf("%c[%d;%dm\nПамять не выделена!%c[%dm\n", 27, 1, 31, 27, 0);
				return;
			}
			newHead->node = node;        //указатель на найденый узел дерева
			newHead->next = head;        //указатель из вершины стека на предыдущий 
			head = newHead;              //новая вершина стека
		} while (node->left || node->right);
		while (head && (!node->right || !node->left)) //цикл по выводу узлов, пока стек не пуст и не узел ветвления
		{
			node = head->node;           //возврат на этот узел ветвления в дереве	
			if ((!node->left || !node->right) || head->flag > 0)
			{
				newHead = head;          //указатель на вершину стека
				head = head->next;       //указатель вниз на следующий элемент стека
				free(newHead);           //удаление из стека указателя на выбранный узел
				printf("%d ", node->info);  //вывод вершины стека
				if (head && head->flag > 0) //если стек и признак того, что можно выводить узел ветвления
				{
					newHead = head;         //указатель на вершину стека
					node = head->node;      //возврат на этот узел ветвления в дереве	
					head = head->next;      //указатель вниз на следующий элемент стека
					free(newHead);          //удаление из стека указателя на выбранный узел
					printf("%d ", node->info);   //вывод вершины стека
					if (head) node = head->node; //для возврата на этот узел ветвления в дереве	
				}
			}
			else break;
		}
		if (head && head->node->left && head->node->right)  //если прошли через узел ветвления
		{
			head->flag++;
		}
		if (head && head->node == root && head->flag > 1)   //если обход закончен и вернулись в корень дерева
		{
			printf("%d ", node->info);                      //вывод корня
			break;                                          //прервать цикл
		}
		if (head && node->right) flag = 0;                  //устанавливаем признак принудительного перехода направо 
		else break;
	}
}